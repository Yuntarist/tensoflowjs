<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tensorflowjs</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@2.0.0/dist/tf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  </head>
  <body>
    <input type="file" name="" id="" onchange="readExcel()" />
    <br />
    아버지 키를 입력해주세요 <input type="number" id="key" />
    <script>
      /* 1. 아버지와 아들 */
      // 아버지와 아들 빈 배열 선언
      let father = [],
        son = []
      // readexcel.js 사용
      const readExcel = () => {
        let input = this.event.target
        let reader = new FileReader()
        reader.onload = function () {
          let data = reader.result
          let wordBook = XLSX.read(data, { type: 'binary' })
          const x = wordBook.Sheets.train
          for (let j = 2; j < 757; j++) {
            let line = [],
              line2 = []
            line.push(x['A' + j].v)
            line2.push(x['B' + j].v)
            father.push(line)
            son.push(line2)
          }
        }
        reader.readAsBinaryString(input.files[0])
      }
      console.log(father)
      console.log(son)
      function bun() {
        let key = document.getElementById('key')
        let kv = Number(key.value)
        console.log(kv)
        let xt = tf.tensor(father)
        let yt = tf.tensor(son)
        let X = tf.input({ shape: [1] })
        let Y = tf.layers.dense({ units: 1 }).apply(X)
        let model = tf.model({ inputs: X, outputs: Y })
        let comileParam = {
          optimizer: tf.train.adam(),
          loss: tf.losses.meanSquaredError
        }
        model.compile(comileParam)
        const fitParm = {
          epochs: 100,
          callbacks: {
            onEpochEnd: function (epoch, logs) {
              console.log('epoch', epoch, logs, 'RMSE=>', Math.sqrt(logs.loss))
            }
          }
        }
        const my = tf.tensor([kv])
        model.fit(xt, yt, fitParm).then((_) => {
          let result = model.predict(my)
          result.print()
        })
      }

      /* 2.그래프 그리기(index.js) */

      // 모델 훈련을 위한 하이퍼파라미터
      const NUM_EPOCHS = 200
      const BATCH_SIZE = 40
      const LEARNING_RATE = 0.01

      const bostonData = new BostonHousingDataset()
      const tensors = {}

      // 로딩된 데이터를 텐서로 변환하고 특성을 정규화합니다.
      export function arraysToTensors() {
        tensors.rawTrainFeatures = tf.tensor2d(bostonData.trainFeatures)
        tensors.trainTarget = tf.tensor2d(bostonData.trainTarget)
        tensors.rawTestFeatures = tf.tensor2d(bostonData.testFeatures)
        tensors.testTarget = tf.tensor2d(bostonData.testTarget)
        /* 평균과 표준 편차로 정규화 내용 추가 */
        let { dataMean, dataStd } = normalization.determineMeanAndStddev(
          tensors.rawTrainFeatures
        )

        tensors.trainFeatures = normalization.normalizeTensor(
          tensors.rawTrainFeatures,
          dataMean,
          dataStd
        )
        tensors.testFeatures = normalization.normalizeTensor(
          tensors.rawTestFeatures,
          dataMean,
          dataStd
        )
      }
      /* 선형 회귀 모델을 만들어 반환 내용 추가 */
      export function linearRegressionModel() {
        const model = tf.sequential()
        model.add(
          tf.layers.dense({ inputShape: [bostonData.numFeatures], units: 1 })
        )
        model.summary()
        return model
      }
      /* data.js */

      /**
       * @license
       * Copyright 2018 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       * http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       * =============================================================================
       */

      // 보스턴 주택 데이터 경로:
      const BASE_URL =
        'https://storage.googleapis.com/tfjs-examples/multivariate-linear-regression/data/'

      const TRAIN_FEATURES_FN = 'train-data.csv'
      const TRAIN_TARGET_FN = 'train-target.csv'
      const TEST_FEATURES_FN = 'test-data.csv'
      const TEST_TARGET_FN = 'test-target.csv'

      /**
       * 이 CSV 데이터는 숫자 배열의 배열을 반환합니다.
       *
       * @param {Array<Object>} data 다운로드된 데이터.
       *
       * @returns {Promise.Array<number[]>} 실수 값으로 파싱된 데이터.
       */
      const parseCsv = async (data) => {
        return new Promise((resolve) => {
          data = data.map((row) => {
            return Object.keys(row).map((key) => parseFloat(row[key]))
          })
          resolve(data)
        })
      }

      /**
       * csv를 다운로드하여 반환합니다.
       *
       * @param {string} filename 다운로드할 파일 이름.
       *
       * @returns {Promise.Array<number[]>} 파싱된 csv 데이터.
       */
      export const loadCsv = async (filename) => {
        return new Promise((resolve) => {
          const url = `${BASE_URL}${filename}`

          console.log(`  * 다음 주소에서 데이터 다운로드 중: ${url}`)
          Papa.parse(url, {
            download: true,
            header: true,
            complete: (results) => {
              resolve(parseCsv(results['data']))
            }
          })
        })
      }

      /** 훈련 데이터와 테스트 데이터 적재를 위한 헬퍼 클래스 */
      export class BostonHousingDataset {
        constructor() {
          // 데이터를 담을 배열
          this.trainFeatures = null
          this.trainTarget = null
          this.testFeatures = null
          this.testTarget = null
        }

        get numFeatures() {
          // 데이터를 로드하기 전에 numFetures를 참조하면 에러를 발생시킵니다.
          if (this.trainFeatures == null) {
            throw new Error("numFeatures 전에 'loadData()'를 호출해야 합니다.")
          }
          return this.trainFeatures[0].length
        }

        /** 훈련 데이터와 테스트 데이터를 적재합니다. */
        async loadData() {
          ;[
            this.trainFeatures,
            this.trainTarget,
            this.testFeatures,
            this.testTarget
          ] = await Promise.all([
            loadCsv(TRAIN_FEATURES_FN),
            loadCsv(TRAIN_TARGET_FN),
            loadCsv(TEST_FEATURES_FN),
            loadCsv(TEST_TARGET_FN)
          ])

          shuffle(this.trainFeatures, this.trainTarget)
          shuffle(this.testFeatures, this.testTarget)
        }
      }

      export const featureDescriptions = [
        '범죄율',
        '주거용 토지 비율',
        '비소매업 비율',
        '강 인접도',
        '일산화질소 농도',
        '평균 방 개수',
        '오래된 주택 비율',
        '고용센터까지 거리',
        '고속도로 접근성',
        '세율',
        '학생-교사 비율',
        '고등교육 이하 비율',
        'ㅇㅅㅇ'
      ]

      /**
       * Fisher-Yates 알고리즘을 사용하여 데이터와 타깃의 쌍을 섞습니다.
       */
      function shuffle(data, target) {
        let counter = data.length
        let temp = 0
        let index = 0
        while (counter > 0) {
          index = (Math.random() * counter) | 0
          counter--
          // 데이터:
          temp = data[counter]
          data[counter] = data[index]
          data[index] = temp
          // 타깃:
          temp = target[counter]
          target[counter] = target[index]
          target[index] = temp
        }
      }

      /* nomalization */
      /**
       * @license
       * Copyright 2018 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       * http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       * =============================================================================
       */

      /**
       * 데이터 배열에 있는 각 열의 평균과 표준 편차를 계산합니다.
       *
       * @param {Tensor2d} data 각 열의 평균과 표준 편차를 독립적으로 계산하기 위한 데이터셋
       *
       * @returns {Object} 각 열의 평균과 표준 편차를 1d 텐서로 포함하고 있는 객체
       */
      export function determineMeanAndStddev(data) {
        const dataMean = data.mean(0)
        const diffFromMean = data.sub(dataMean)
        const squaredDiffFromMean = diffFromMean.square()
        const variance = squaredDiffFromMean.mean(0)
        const dataStd = variance.sqrt()
        return { dataMean, dataStd }
      }

      /**
       * 평균과 표준 편차가 주어지면 평균을 빼고 표준 편차로 나누어 정규화합니다.
       *
       * @param {Tensor2d} data 정규화할 데이터. 크기: [batch, numFeatures].
       * @param {Tensor1d} dataMean 데이터의 평균. 크기 [numFeatures].
       * @param {Tensor1d} dataStd 데이터의 표준 편차. 크기 [numFeatures]
       *
       * @returns {Tensor2d} data와 동일한 크기의 텐서이지만,
       * 각 열은 평균이 0이고 단위 표준 편차를 가지도록 정규화되어 있습니다.
       */
      export function normalizeTensor(data, dataMean, dataStd) {
        return data.sub(dataMean).div(dataStd)
      }
      /* ui.js */
      /**
       * @license
       * Copyright 2018 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       * http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       * =============================================================================
       */

      import {
        linearRegressionModel,
        multiLayerPerceptronRegressionModel1Hidden,
        multiLayerPerceptronRegressionModel2Hidden,
        multiLayerPerceptronRegressionModel1HiddenNoSigmoid,
        run
      } from './index.js'

      const statusElement = document.getElementById('status')
      export function updateStatus(message) {
        statusElement.innerText = message
      }

      const baselineStatusElement = document.getElementById('baselineStatus')
      export function updateBaselineStatus(message) {
        baselineStatusElement.innerText = message
      }

      export function updateModelStatus(message, modelName) {
        const statElement = document.querySelector(`#${modelName} .status`)
        statElement.innerText = message
      }

      const NUM_TOP_WEIGHTS_TO_DISPLAY = 13
      /**
       * 간단한 선형 모델에서 학습된 가중치에 관한 정보를 업데이트합니다.
       *
       * @param {List} weightsList 'value':number 와 'description':string 의 객체 리스트
       */
      export function updateWeightDescription(weightsList) {
        const inspectionHeadlineElement =
          document.getElementById('inspectionHeadline')
        inspectionHeadlineElement.innerText = `가장 큰 가중치 상위 ${NUM_TOP_WEIGHTS_TO_DISPLAY}개`
        // 절댓값 크기로 가중치를 정렬합니다.
        weightsList.sort((a, b) => Math.abs(b.value) - Math.abs(a.value))
        var table = document.getElementById('myTable')
        // 테이블을 초기화합니다.
        table.innerHTML = ''
        // 테이블에 행을 추가합니다.
        weightsList.forEach((weight, i) => {
          if (i < NUM_TOP_WEIGHTS_TO_DISPLAY) {
            let row = table.insertRow(-1)
            let cell1 = row.insertCell(0)
            let cell2 = row.insertCell(1)
            if (weight.value < 0) {
              cell2.setAttribute('class', 'negativeWeight')
            } else {
              cell2.setAttribute('class', 'positiveWeight')
            }
            cell1.innerHTML = weight.description
            cell2.innerHTML = weight.value.toFixed(4)
          }
        })
      }

      export async function setup() {
        const trainSimpleLinearRegression =
          document.getElementById('simple-mlr')
        const trainNeuralNetworkLinearRegression1Hidden =
          document.getElementById('nn-mlr-1hidden')
        const trainNeuralNetworkLinearRegression2Hidden =
          document.getElementById('nn-mlr-2hidden')
        const trainNeuralNetworkLinearRegression1HiddenNoSigmoid =
          document.getElementById('nn-mlr-1hidden-no-sigmoid')

        trainSimpleLinearRegression.addEventListener(
          'click',
          async (e) => {
            const model = linearRegressionModel()
            await run(model, 'linear', true)
          },
          false
        )

        trainNeuralNetworkLinearRegression1Hidden.addEventListener(
          'click',
          async () => {
            const model = multiLayerPerceptronRegressionModel1Hidden()
            await run(model, 'oneHidden', false)
          },
          false
        )

        trainNeuralNetworkLinearRegression2Hidden.addEventListener(
          'click',
          async () => {
            const model = multiLayerPerceptronRegressionModel2Hidden()
            await run(model, 'twoHidden', false)
          },
          false
        )

        trainNeuralNetworkLinearRegression1HiddenNoSigmoid.addEventListener(
          'click',
          async () => {
            const model = multiLayerPerceptronRegressionModel1HiddenNoSigmoid()
            await run(model, 'nosigHidden', false)
          },
          false
        )
      }
    </script>
  </body>
</html>
